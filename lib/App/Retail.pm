package App::Retail;
use strict;
use warnings;
use Fcntl;
use SDBM_File;
use File::Basename;
use Digest::SHA1 qw /sha1_hex sha1_base64/;
use Carp;

sub new {
    my ( $class, $args ) = @_;

    my $self = {};
    $self->{debug} = $args->{debug}||0;
    $self->{state} = $args->{state}||"/tmp";
    $self->{filepattern} = $args->{filepattern}||croak "filepattern required";

    bless $self, $class;
    return $self;
}

sub extract_log_lines {
    my ( $self ) = @_;

    my ( %state, %touched, %handles );

    my $statefile = $self->get_state_file;

    # open the state file
    tie (%state, 'SDBM_File', $statefile, O_RDWR|O_CREAT, 0666) || die "$statefile: $!\n";

    my @files_to_process = $self->get_files;

    # open filehandles for all files before processing in case some
    # files go away while we're processing others
    foreach my $file (@files_to_process) {
        my $fh;
        if (sysopen ($fh, $file, O_RDONLY)) {
            $handles{$file} = $fh;
        } else {
            print "DEBUG: sysopen failed on $file: $!\n" if ($self->debug);
        }
    }

    foreach my $file (@files_to_process) {

        # start at the beginning of the file or, if defined, the offset
        # saved in the state file
        my $offset = 0;
        if (defined ($state{"OFFSET:$file"})) {
            $offset = $state{"OFFSET:$file"};
        }

        print "DEBUG: open $file: $offset\n" if ($self->debug);

        # if file has a previously opened file handle, process it
        # otherwise continue to next file
        if (!defined ($handles{$file})) {
            print "DEBUG: no file handle for $file\n" if ($self->debug);
            next;
        }

        # seek, read/print, and close file
        my $fh = $handles{$file};
        sysseek ($fh, $offset, 0);
        my $line;
        while (my $bytes = sysread ($fh, $line, 1024)) {
            if ($self->debug) {
                if ($line !~ /\n$/) {
                    print '.';
                } else {
                    print '+';
                }
            }
            $offset += $bytes;
            print "$line";
        }
        close ($fh);

        # save offset for next run
        $state{"OFFSET:$file"} = $offset;

        # we saw this file (used later for cleaning up state file)
        $touched{$file} = 1;

        print "\nDEBUG: close $file: $offset\n" if ($self->debug);
    }

    # clean up the state file - remove entries for files that are no longer here
    foreach my $key (keys %state) {
        my (undef, $file) = (split (/:/, $key, 2));
        if (!defined ($touched{$file})) {
            print "DEBUG: remove $file\n" if ($self->debug);
            delete ($state{$key});
        }
    }

    # close up shop
    untie (%state);
    exit 0;

}

sub get_state_file {
    my ( $self ) = @_;

    # To avoid multiple instances of retail clobbering each other's state
    # files, we use a unique state file generated by the SHA-1 hash of the
    # given file pattern, if given a state path that's a directory.  If
    # otherwise, check that dirname of path is a directory and assume the
    # state path is the file name.
    my $statefile;
    if (-d $self->statepath) {
        $statefile = "$self->statepath/retail-" . sha1_hex($self->filepattern);
    } else {
        my $dirname = dirname ($self->statepath);
        if (-d $dirname) {
            $statefile = $self->statepath;
        } else {
            die "Cannot access state file: $!\n";
        }
    }

    return $statefile;
}

sub get_files {
    my ( $self ) = @_;

    my $dirname = dirname ($self->filepattern);
    my $pattern = basename ($self->filepattern);
    my (@files, %stat);

    opendir (D, $dirname);
    my @dirfiles = readdir (D);
    closedir (D);

    print "DEBUG: matching pattern: $pattern\n" if ($self->debug);

    foreach my $file (@dirfiles) {
        if ( $file =~ /^$pattern$/ ) {
            push @files, "$dirname/$file";
            $stat{"$dirname/$file"} = (stat ("$dirname/$file"))[10];
        }
    }

    return (sort { $stat{$a} <=> $stat{$b} } @files);
}

1;

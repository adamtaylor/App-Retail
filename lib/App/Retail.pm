use strict;
use warnings;
package App::Retail;

sub new {
    my ( $class, $args ) = @_;
}

sub get_files {
    my ($filepattern) = @_;
    my $dirname = dirname ($filepattern);
    my $pattern = basename ($filepattern);
    my (@files, %stat);

    opendir (D, $dirname);
    my @dirfiles = readdir (D);
    closedir (D);
    print STDERR "DEBUG: matching pattern: $pattern\n" if ($DEBUG);
    foreach my $file (@dirfiles) {
        if ($file =~ /^$pattern$/) {
            push @files, "$dirname/$file";
            $stat{"$dirname/$file"} = (stat ("$dirname/$file"))[10];
        }
    }

    return (sort { $stat{$a} <=> $stat{$b} } @files);
}

sub extract_log_lines {

}

1;

# XXX rewrite/refactor
MAIN:
{
    my (%opts, $filepattern, %state, %touched, %handles);

# -d: turn on debugging output
# -f <filepattern>: process these file patterns
# -h: print usage
# -s <state file path>: directory in which to save state files
    getopts('df:hs:', \%opts);

    if ($opts{'h'}) {
        usage();
        exit;
    }

    $DEBUG = 1 if ($opts{'d'});
    $STATEPATH = $opts{'s'} if ($opts{'s'});

    if ($opts{'f'}) {
        $filepattern = $opts{'f'};
    } else {
        die "Need file pattern!\n";
    }

# To avoid multiple instances of retail clobbering each other's state
# files, we use a unique state file generated by the SHA-1 hash of the
# given file pattern, if given a state path that's a directory.  If
# otherwise, check that dirname of path is a directory and assume the
# state path is the file name.
    my $statefile;
    if (-d $STATEPATH) {
        $statefile = "$STATEPATH/retail-" . sha1_hex($filepattern);
    } else {
        my $dirname = dirname ($STATEPATH);
        if (-d $dirname) {
            $statefile = $STATEPATH;
        } else {
            die "Cannot access state file: $!\n";
        }
    }

# open the state file
    tie (%state, 'NDBM_File', $statefile, O_RDWR|O_CREAT, 0666) || die "$statefile: $!\n";

# get list of files to process
    my @files_to_process = getfiles ($filepattern);

# open filehandles for all files before processing in case some
# files go away while we're processing others
    foreach my $file (@files_to_process) {
        my $fh;
        if (sysopen ($fh, $file, O_RDONLY)) {
            $handles{$file} = $fh;
        } else {
            print STDERR "DEBUG: sysopen failed on $file: $!\n" if ($DEBUG);
        }
    }

    foreach my $file (@files_to_process) {

# start at the beginning of the file or, if defined, the offset
# saved in the state file
        my $offset = 0;
        if (defined ($state{"OFFSET:$file"})) {
            $offset = $state{"OFFSET:$file"};
        }

        print STDERR "DEBUG: open $file: $offset\n" if ($DEBUG);

# if file has a previously opened file handle, process it
# otherwise continue to next file
        if (!defined ($handles{$file})) {
            print STDERR "DEBUG: no file handle for $file\n" if ($DEBUG);
            next;
        }

# seek, read/print, and close file
        my $fh = $handles{$file};
        sysseek ($fh, $offset, 0);
        my $line;
        while (my $bytes = sysread ($fh, $line, 1024)) {
            if ($DEBUG) {
                if ($line !~ /\n$/) {
                    print STDERR '.';
                } else {
                    print STDERR '+';
                }
            }
            $offset += $bytes;
            print "$line";
        }
        close ($fh);

# save offset for next run
        $state{"OFFSET:$file"} = $offset;

# we saw this file (used later for cleaning up state file)
        $touched{$file} = 1;

        print STDERR "\nDEBUG: close $file: $offset\n" if ($DEBUG);
    }

# clean up the state file - remove entries for files that are no longer here
    foreach my $key (keys %state) {
        my (undef, $file) = (split (/:/, $key, 2));
        if (!defined ($touched{$file})) {
            print STDERR "DEBUG: remove $file\n" if ($DEBUG);
            delete ($state{$key});
        }
    }

# close up shop
    untie (%state);
    exit 0;
}
